# 算法性能优化

### 尽量使用HashMap

优点：

* 性能高，查询快速
* 动态可变长

缺点：

* 非线程安全

> 【推荐】集合初始化时，指定集合初始值大小。  
> 说明：HashMap 使用 HashMap(int initialCapacity) 初始化  
> 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。  
> 反例：HashMap 需要放置1024个元素，由于没有设置初始值大小，随着元素不断增加，容量七次被迫扩大，resize 需要重建哈希表，严重影响性能。
> 
> ——《阿里巴巴Java开发手册》

具体内容见[HashMap笔记](./HashMapNote.md)

### 使用移位运算符代替乘除
* `<<` : 左移，不分正负数，低位补0
```Java
10<<1                 // 20
Integer.MAX_VALUE<<1  // -2
```

* `>>` : 带符号右移（算数右移）。正数右移高位补 0，负数右移高位补 1
```Java
4>>1    // 2
-4>>1   // -2
```

* `>>>` ：无符号右移（逻辑右移）。无论正数还是负数，高位通通补0
```Java
// 对于正数而言，>>和>>>没有区别; 对于负数而言,高位补0
-2>>>1  // 结果是2147483647（Integer.MAX_VALUE） 1111 1111 1111 1111 1111 1111 1111 1110 >>>1  右移1位补1
-1>>>1  // 结果是2147483647（Integer.MAX_VALUE） 1111 1111 1111 1111 1111 1111 1111 1111 >>>1  右移1位补1
```

> 对char，byte或者short进行移位处理，那么在移位进行之前，它们会自动转换成一个int。只有右侧的5个低位才会有用。这样可防止我们在一个int数里移动不切实际的位数。若对一个long值进行处理，最后得到的结果也是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。 
>
>  ——《Thinking in java》

### 涉及到多次对字符串的大量操作采用StringBuilder

* 少量的字符串操作用 `String`
* **单线程对字符串缓冲区进行大量操作** `StringBuilder`
* 多线程对字符串缓冲区进行大量操作 `StringBuffer`

具体内容见[字符串处理笔记](./StringAndStringBuilder.md)


## 参考文献
* [理解java移位运算符](https://www.cnblogs.com/winsker/p/6728672.html)